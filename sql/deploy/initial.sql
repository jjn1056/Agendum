BEGIN;

-- 1. Utility Function to Update 'updated_at' Automatically
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Person Table

CREATE TYPE user_status AS ENUM ('pending', 'active', 'inactive', 'archived', 'banned', 'deleted');

CREATE TABLE person (
    person_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Identity-based primary key
    email TEXT NOT NULL UNIQUE, -- Unique email address
    given_name TEXT, -- First name
    family_name TEXT, -- Last name
    password TEXT, -- User password
    status user_status NOT NULL DEFAULT 'pending', -- User status
    created_at TIMESTAMPTZ DEFAULT NOW(), -- Record creation timestamp
    updated_at TIMESTAMPTZ DEFAULT NOW() -- Record update timestamp
);

CREATE INDEX idx_person_person_id ON person(person_id);

-- Trigger to Automatically Update 'updated_at' for Person
CREATE TRIGGER trigger_update_person_updated_at
BEFORE UPDATE ON person
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

-- 3. Task Status Enum Type
CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'on_hold', 'blocked', 'canceled', 'completed');

-- 4. Tasks Table
CREATE TABLE tasks (
    task_id INT GENERATED BY DEFAULT AS IDENTITY, -- Unique task ID within a person
    person_id INT NOT NULL REFERENCES person(person_id) ON DELETE CASCADE, -- Link tasks to a specific person
    title VARCHAR(255) NOT NULL, -- Task title
    description TEXT, -- Task description
    due_date DATE NOT NULL, -- Due date of the task
    priority INT DEFAULT 1 CHECK (priority BETWEEN 1 AND 5), -- Priority constrained to 1-5
    status task_status DEFAULT 'pending', -- Status of the task
    created_at TIMESTAMPTZ DEFAULT NOW(), -- Record creation timestamp
    updated_at TIMESTAMPTZ DEFAULT NOW(), -- Record update timestamp
    PRIMARY KEY (person_id, task_id) -- Composite primary key
);

-- Indexes for Optimized Queries on Tasks
CREATE INDEX idx_tasks_due_date_priority_status ON tasks (due_date, priority, status);
CREATE INDEX idx_tasks_due_date ON tasks (due_date);
CREATE INDEX idx_tasks_priority ON tasks (priority);
CREATE INDEX idx_tasks_status ON tasks (status);

-- Trigger to Automatically Update 'updated_at' for Tasks
CREATE TRIGGER trigger_update_tasks_updated_at
BEFORE UPDATE ON tasks
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();

-- Function to Enforce Due Date Constraint on Insert
CREATE OR REPLACE FUNCTION check_due_date_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.due_date < CURRENT_DATE THEN
        RAISE EXCEPTION 'due_date must be in the future';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to Enforce Due Date Constraint on Insert
CREATE TRIGGER enforce_due_date_on_insert
BEFORE INSERT ON tasks
FOR EACH ROW
EXECUTE FUNCTION check_due_date_on_insert();

-- 5. Comments Table
CREATE TABLE comments (
    comment_id INT GENERATED BY DEFAULT AS IDENTITY, -- Unique comment ID
    person_id INT NOT NULL, -- Person ID
    task_id INT NOT NULL, -- Task ID
    content TEXT NOT NULL, -- Comment content
    created_at TIMESTAMPTZ DEFAULT NOW(), -- Comment creation timestamp
    PRIMARY KEY (person_id, task_id, comment_id), -- Composite primary key including person_id and task_id
    FOREIGN KEY (person_id, task_id) REFERENCES tasks(person_id, task_id) ON DELETE CASCADE -- Cascade on delete
);

-- Indexes for Optimized Queries on Comments
CREATE INDEX idx_comments_person_task_comment ON comments (person_id, task_id, comment_id);

-- Trigger to Update Task's 'updated_at' After Comment Insert
CREATE OR REPLACE FUNCTION update_tasks_timestamp_on_comments_insert()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE tasks SET updated_at = NOW()
    WHERE person_id = NEW.person_id AND task_id = NEW.task_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_tasks_on_comments_insert
AFTER INSERT ON comments
FOR EACH ROW
EXECUTE FUNCTION update_tasks_timestamp_on_comments_insert();

-- 6. Labels Table (Globally Unique Labels)
CREATE TABLE labels (
    label_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Globally unique label ID
    name VARCHAR(100) NOT NULL UNIQUE, -- Unique label name
    created_at TIMESTAMPTZ DEFAULT NOW() -- Record creation timestamp
);

-- 7. Task-Labels Many-to-Many Relationship
CREATE TABLE task_labels (
    person_id INT NOT NULL, -- Person ID
    task_id INT NOT NULL, -- Task ID
    label_id INT NOT NULL, -- Label ID
    PRIMARY KEY (person_id, task_id, label_id), -- Composite primary key
    FOREIGN KEY (person_id, task_id) REFERENCES tasks(person_id, task_id) ON DELETE CASCADE, -- Cascade on delete
    FOREIGN KEY (label_id) REFERENCES labels(label_id) ON DELETE CASCADE -- Cascade on delete
);

-- Indexes for Optimized Queries on Task-Labels
CREATE INDEX idx_task_labels_person_task ON task_labels (person_id, task_id);
CREATE INDEX idx_task_labels_label ON task_labels (label_id);

-- Trigger to Update Task's 'updated_at' After Task-Label Insert
CREATE OR REPLACE FUNCTION update_tasks_timestamp_on_task_labels_insert()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE tasks SET updated_at = NOW()
    WHERE person_id = NEW.person_id AND task_id = NEW.task_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_tasks_on_task_labels_insert
AFTER INSERT ON task_labels
FOR EACH ROW
EXECUTE FUNCTION update_tasks_timestamp_on_task_labels_insert();

-- Trigger to Update Task's 'updated_at' After Task-Label Delete
CREATE OR REPLACE FUNCTION update_tasks_timestamp_on_task_labels_delete()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE tasks SET updated_at = NOW()
    WHERE person_id = OLD.person_id AND task_id = OLD.task_id;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_tasks_on_task_labels_delete
AFTER DELETE ON task_labels
FOR EACH ROW
EXECUTE FUNCTION update_tasks_timestamp_on_task_labels_delete();

-- Insert Default Labels
INSERT INTO labels (name)
VALUES
('work'),
('personal'),
('health'),
('follow_up'),
('planning'),
('meeting'),
('errand'),
('research'),
('shopping'),
('travel'),
('financial'),
('learning'),
('creative'),
('family');

COMMIT;


